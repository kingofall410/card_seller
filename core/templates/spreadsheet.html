{% load static custom_tags %}
<!DOCTYPE html>
<html>
<head>
  <title>Card Spreadsheet</title>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/handsontable@13.0.0/dist/handsontable.min.css">
  <script src="https://cdn.jsdelivr.net/npm/dompurify@2.4.0/dist/purify.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/handsontable@13.0.0/dist/handsontable.min.js"></script>


  <style>

    #spreadsheet {
      margin-top: 1rem;
      width: 100%;
    }
  </style>
</head>

<link rel="stylesheet" href="https://code.jquery.com/ui/1.13.2/themes/base/jquery-ui.css">
<script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
<script src="https://code.jquery.com/ui/1.13.2/jquery-ui.min.js"></script>
<script src="{% static 'js/search_results.js' %}"></script>
<body>

<div class="spreadsheet-scroll-wrapper">
  <div id="spreadsheet"></div>
</div>
<div id="image-tooltip" style="
  position: absolute;
  display: none;
  pointer-events: none;
  z-index: 1000;
  border: 1px solid #ccc;
  background: white;
  padding: 4px;
  box-shadow: 0 2px 6px rgba(0,0,0,0.2);
">
  <img id="tooltip-image" src="" alt="Preview" style="max-width: 200px; max-height: 200px;">
</div>


{{ columns|json_script:"card_columns" }}
{{ rows|json_script:"card_rows" }}

<script>

function linkRenderer(instance, td, row, col, prop, value, cellProperties) {
  const card_id = instance.getDataAtRowProp(row, 'card_id'); // 👈 access another field
  td.innerHTML = `<a href="/card/${card_id}">${value}</a>`;
  td.classList.add('htCenter');
  return td;
}


let isApplyingServerUpdate = false;

document.addEventListener('DOMContentLoaded', () => {
  const container = document.getElementById('spreadsheet');
  const columns = JSON.parse(document.getElementById('card_columns').textContent);
  const rows = JSON.parse(document.getElementById('card_rows').textContent);
  console.log(columns)
  console.log(rows)
  const hot = new Handsontable(container, {
    data: rows,
    colHeaders: columns,
    rowHeaders: true,
    stretchH: 'all',
    licenseKey: 'non-commercial-and-evaluation',
    columns: columns.map(col => {
      if (col === 'id') {
        return { data: col, renderer: linkRenderer };
      }
      return { data: col, type: 'text' };
    }),

    manualColumnResize: true,
    manualRowResize: true,
    manualColumnMove: true,
    contextMenu: true,
    autoRowSize: false,
    dropdownMenu: true,
    filters: true,
    columnSorting: true,

    // ✅ Enable copy/paste
    copyPaste: {
      rowsLimit: 1000,
      columnsLimit: 100,
      pasteMode: 'overwrite', // or 'shift_down'
    },

    afterChange: function(changes, source) {
      if (isApplyingServerUpdate) {
        console.log("afterChange skipping");
        return;
      }

      console.log("afterChange executing");

      if (source === 'edit' || source === 'CopyPaste.paste') {
        const columnMap = hot.getSettings().columns.map(col => col.data);
        const rowChanges = {};

        // 🧩 Accumulate changes per row
        changes.forEach(([row, prop, oldValue, newValue]) => {
          const fieldName = typeof prop === 'string' ? prop : columnMap[prop];
          if (!rowChanges[row]) rowChanges[row] = {};
          rowChanges[row][fieldName] = newValue;
        });

        // 🧾 Include brand/city + is_manual flags
        Object.entries(rowChanges).forEach(([rowIndex, fields]) => {
          const row = parseInt(rowIndex);
          const brand = hot.getDataAtCell(row, columnMap.indexOf('brand'));
          const city = hot.getDataAtCell(row, columnMap.indexOf('city'));

          const brandChanged = Object.prototype.hasOwnProperty.call(fields, 'brand');
          const cityChanged = Object.prototype.hasOwnProperty.call(fields, 'city');

          if (!brandChanged) fields.brand = brand;
          if (!cityChanged) fields.city = city;

          fields.brand_is_manual = brandChanged;
          fields.city_is_manual = cityChanged;

          quickEdit(hot, row, fields);
        });
      }
    }
  });
  
  let tooltipTimeout;

  hot.addHook('afterOnCellMouseOver', function(event, coords, TD) {
    
    clearTimeout(tooltipTimeout);  // cancel any previous delay
    
    const sourceData = hot.getSourceDataArray()
    const visibleRowIndex = coords.row;
    const visibleRowData = hot.getDataAtRow(visibleRowIndex);
    
    //console.log(visibleRowData)
    
    const hoverCsr = visibleRowData[0];
    const sourceDataIndex = sourceData.findIndex(row => row[0] == hoverCsr);
    //console.log("dummy", hoverCsr, sourceDataIndex)
    //console.log(hot.getDataAtRow(visibleRowIndex))
    //console.log(sourceData)
    const rows = JSON.parse(document.getElementById('card_rows').textContent);
    //console.log(rows)
    const sourceRow = rows[sourceDataIndex];
    if (sourceRow == null) return;

    const thumbUrl = sourceRow["thumb_url"]
    if (!thumbUrl) return;
    
    tooltipTimeout = setTimeout(() => {
      const tooltip = document.getElementById('image-tooltip');
      const img = document.getElementById('tooltip-image');
      img.src = thumbUrl;

      tooltip.style.left = `${event.pageX + 10}px`;
      tooltip.style.top = `${event.pageY + 10}px`;
      tooltip.style.max_width = '400px';
      tooltip.style.max_height = '400px';
      tooltip.style.width = 'auto';
      tooltip.style.height = 'auto';      
      tooltip.style.display = 'block';
      tooltip.style.object_fit = 'contain';
    }, 300);  // ⏱ delay in milliseconds
  });

  hot.addHook('afterOnCellMouseOut', function(event, coords, TD) {
    clearTimeout(tooltipTimeout);  // cancel if mouse leaves early
    const tooltip = document.getElementById('image-tooltip');
    tooltip.style.display = 'none';
  });


});
function quickEdit(hot, visualRow, updatedFields) {
  console.log("QE", hot, visualRow);

  // Step 1: Get visible row data
  const visibleRowData = hot.getDataAtRow(visualRow);
  const csrId = visibleRowData[0]; // assuming ID is in column 0

  // Step 2: Resolve source index using getSourceDataArray
  const sourceData = hot.getSourceDataArray();
  const sourceRowIndex = sourceData.findIndex(row => String(row[0]) == csrId);

  if (sourceRowIndex < 0) {
    console.warn("Source row not found for csrId:", csrId);
    return;
  }

  // Step 3: Send update to server
  $.ajax({
    url: "/update_csr_fields/",
    method: "POST",
    contentType: "application/json",
    data: JSON.stringify({
      csrId: csrId,
      allFields: updatedFields
    }),
    success: response => {
      const updatedFields = response.search_result;
      const visualRowIndex = hot.toVisualRow(sourceRowIndex);
      console.log(visualRowIndex)
      if (visualRowIndex < 0) {
        console.warn("Visual row not found for csrId:", csrId);
        return;
      }

      // Step 4: Apply updates to visible table
      Object.entries(updatedFields).forEach(([field, value]) => {
        if (!field || typeof field !== 'string') return;

        const columnExists = hot.getSettings().columns.some(col => col.data === field);
        if (!columnExists) return;

        isApplyingServerUpdate = true;
        hot.setDataAtRowProp(visualRowIndex, field, value);
        isApplyingServerUpdate = false;
      });
    },
    error: xhr => {
      console.error("Save error:", xhr.responseText);
      alert("Error saving changes.");
    }
  });
}


</script>


</body>
</html>
